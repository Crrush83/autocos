// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cos_comm.proto

#include "cos_comm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
extern PROTOBUF_INTERNAL_EXPORT_cos_5fcomm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosLavaDBIndex_cos_5fcomm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cos_5fcomm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosTfsIndex_cos_5fcomm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cos_5fcomm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_cacheinfo_cos_5fcomm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cos_5fcomm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_idcitem_cos_5fcomm_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_cos_5fcomm_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_storeinfo_cos_5fcomm_2eproto;
class ShaMainRecordDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ShaMainRecord> _instance;
} _ShaMainRecord_default_instance_;
class CasKeyRecordDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CasKeyRecord> _instance;
} _CasKeyRecord_default_instance_;
class PartRecordDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PartRecord> _instance;
} _PartRecord_default_instance_;
class CosDataIndexDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosDataIndex> _instance;
} _CosDataIndex_default_instance_;
class CosDataIndexRspDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosDataIndexRsp> _instance;
} _CosDataIndexRsp_default_instance_;
class CosPartItemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosPartItem> _instance;
} _CosPartItem_default_instance_;
class CosPartdeleteItemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosPartdeleteItem> _instance;
} _CosPartdeleteItem_default_instance_;
class delstorinfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<delstorinfo> _instance;
} _delstorinfo_default_instance_;
class storeinfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<storeinfo> _instance;
} _storeinfo_default_instance_;
class cacheinfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<cacheinfo> _instance;
} _cacheinfo_default_instance_;
class idcitemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<idcitem> _instance;
} _idcitem_default_instance_;
class sha1storeinfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<sha1storeinfo> _instance;
} _sha1storeinfo_default_instance_;
class CosUploadCacheDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosUploadCacheData> _instance;
} _CosUploadCacheData_default_instance_;
class CosTfsIndexDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosTfsIndex> _instance;
} _CosTfsIndex_default_instance_;
class CheckTfsinfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CheckTfsinfo> _instance;
} _CheckTfsinfo_default_instance_;
class CosLavaDBIndexDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CosLavaDBIndex> _instance;
} _CosLavaDBIndex_default_instance_;
class CheckLavaDBinfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CheckLavaDBinfo> _instance;
} _CheckLavaDBinfo_default_instance_;
static void InitDefaultsscc_info_CasKeyRecord_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CasKeyRecord_default_instance_;
    new (ptr) ::CasKeyRecord();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CasKeyRecord_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CasKeyRecord_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CheckLavaDBinfo_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CheckLavaDBinfo_default_instance_;
    new (ptr) ::CheckLavaDBinfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CheckLavaDBinfo_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_CheckLavaDBinfo_cos_5fcomm_2eproto}, {
      &scc_info_CosLavaDBIndex_cos_5fcomm_2eproto.base,}};

static void InitDefaultsscc_info_CheckTfsinfo_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CheckTfsinfo_default_instance_;
    new (ptr) ::CheckTfsinfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CheckTfsinfo_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_CheckTfsinfo_cos_5fcomm_2eproto}, {
      &scc_info_CosTfsIndex_cos_5fcomm_2eproto.base,}};

static void InitDefaultsscc_info_CosDataIndex_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosDataIndex_default_instance_;
    new (ptr) ::CosDataIndex();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosDataIndex_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosDataIndex_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CosDataIndexRsp_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosDataIndexRsp_default_instance_;
    new (ptr) ::CosDataIndexRsp();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosDataIndexRsp_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosDataIndexRsp_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CosLavaDBIndex_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosLavaDBIndex_default_instance_;
    new (ptr) ::CosLavaDBIndex();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosLavaDBIndex_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosLavaDBIndex_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CosPartItem_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosPartItem_default_instance_;
    new (ptr) ::CosPartItem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosPartItem_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosPartItem_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CosPartdeleteItem_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosPartdeleteItem_default_instance_;
    new (ptr) ::CosPartdeleteItem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosPartdeleteItem_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosPartdeleteItem_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CosTfsIndex_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosTfsIndex_default_instance_;
    new (ptr) ::CosTfsIndex();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosTfsIndex_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosTfsIndex_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_CosUploadCacheData_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_CosUploadCacheData_default_instance_;
    new (ptr) ::CosUploadCacheData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CosUploadCacheData_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CosUploadCacheData_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_PartRecord_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_PartRecord_default_instance_;
    new (ptr) ::PartRecord();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PartRecord_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PartRecord_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_ShaMainRecord_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_ShaMainRecord_default_instance_;
    new (ptr) ::ShaMainRecord();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ShaMainRecord_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ShaMainRecord_cos_5fcomm_2eproto}, {
      &scc_info_idcitem_cos_5fcomm_2eproto.base,}};

static void InitDefaultsscc_info_cacheinfo_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_cacheinfo_default_instance_;
    new (ptr) ::cacheinfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_cacheinfo_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_cacheinfo_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_delstorinfo_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_delstorinfo_default_instance_;
    new (ptr) ::delstorinfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_delstorinfo_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_delstorinfo_cos_5fcomm_2eproto}, {
      &scc_info_storeinfo_cos_5fcomm_2eproto.base,}};

static void InitDefaultsscc_info_idcitem_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_idcitem_default_instance_;
    new (ptr) ::idcitem();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_idcitem_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_idcitem_cos_5fcomm_2eproto}, {}};

static void InitDefaultsscc_info_sha1storeinfo_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_sha1storeinfo_default_instance_;
    new (ptr) ::sha1storeinfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_sha1storeinfo_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_sha1storeinfo_cos_5fcomm_2eproto}, {
      &scc_info_storeinfo_cos_5fcomm_2eproto.base,
      &scc_info_cacheinfo_cos_5fcomm_2eproto.base,}};

static void InitDefaultsscc_info_storeinfo_cos_5fcomm_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_storeinfo_default_instance_;
    new (ptr) ::storeinfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_storeinfo_cos_5fcomm_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_storeinfo_cos_5fcomm_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_cos_5fcomm_2eproto[17];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_cos_5fcomm_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_cos_5fcomm_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_cos_5fcomm_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, ref_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, ctime_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, mtime_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, fsize_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, hitflag_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, type_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, idclist_),
  PROTOBUF_FIELD_OFFSET(::ShaMainRecord, is_chunk_),
  0,
  1,
  3,
  2,
  5,
  4,
  ~0u,
  6,
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, ref_),
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, ctime_),
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, mtime_),
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, fsize_),
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, archive_id_),
  PROTOBUF_FIELD_OFFSET(::CasKeyRecord, type_),
  1,
  2,
  4,
  3,
  0,
  5,
  PROTOBUF_FIELD_OFFSET(::PartRecord, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::PartRecord, sha_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, fsize_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, isfinished_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, ctime_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, offset_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, id_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, mtime_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, slicesize_),
  PROTOBUF_FIELD_OFFSET(::PartRecord, real_sha_),
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  1,
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, chid_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, fid_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, datasize_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, offset_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, ctime_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, dataflag_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, crc_num_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndex, cachekey_),
  2,
  3,
  5,
  4,
  6,
  0,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, datakey_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, version_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, chid_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, fid_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, storeid_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, datasize_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, crc_num_),
  PROTOBUF_FIELD_OFFSET(::CosDataIndexRsp, cachekey_),
  0,
  1,
  3,
  4,
  5,
  6,
  7,
  2,
  PROTOBUF_FIELD_OFFSET(::CosPartItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosPartItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosPartItem, partnum_),
  PROTOBUF_FIELD_OFFSET(::CosPartItem, sha_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CosPartdeleteItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosPartdeleteItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosPartdeleteItem, isfinish_),
  PROTOBUF_FIELD_OFFSET(::CosPartdeleteItem, sha_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::delstorinfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::delstorinfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::delstorinfo, info_),
  PROTOBUF_FIELD_OFFSET(::delstorinfo, id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::storeinfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::storeinfo, tfs_cl5_modid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, tfs_cl5_cmid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, lavadb_cl5_modid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, lavadb_cl5_cmid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, lavadb_tid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, lavadb_cid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, idcnum_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, isprefix_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, isusetfscl5_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, use_local_tfsproxy_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, name_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, use_cache_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, cache_cl5_modid_),
  PROTOBUF_FIELD_OFFSET(::storeinfo, cache_cl5_cmdid_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  9,
  8,
  10,
  0,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::cacheinfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::cacheinfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::cacheinfo, lavadb_cl5_modid_),
  PROTOBUF_FIELD_OFFSET(::cacheinfo, lavadb_cl5_cmdid_),
  PROTOBUF_FIELD_OFFSET(::cacheinfo, lavadb_tid_),
  PROTOBUF_FIELD_OFFSET(::cacheinfo, lavadb_cid_),
  PROTOBUF_FIELD_OFFSET(::cacheinfo, idcnum_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::idcitem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::idcitem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::idcitem, idc_),
  PROTOBUF_FIELD_OFFSET(::idcitem, ctime_),
  PROTOBUF_FIELD_OFFSET(::idcitem, uploadstate_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::sha1storeinfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::sha1storeinfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::sha1storeinfo, sha_),
  PROTOBUF_FIELD_OFFSET(::sha1storeinfo, info_),
  PROTOBUF_FIELD_OFFSET(::sha1storeinfo, cache_info_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CosUploadCacheData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosUploadCacheData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosUploadCacheData, datasize_),
  PROTOBUF_FIELD_OFFSET(::CosUploadCacheData, offset_),
  PROTOBUF_FIELD_OFFSET(::CosUploadCacheData, ctime_),
  PROTOBUF_FIELD_OFFSET(::CosUploadCacheData, value_),
  2,
  1,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, chid_),
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, fid_),
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, datasize_),
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, offset_),
  PROTOBUF_FIELD_OFFSET(::CosTfsIndex, ctime_),
  0,
  1,
  3,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, tfs_cl5_modid_),
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, tfs_cl5_cmid_),
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, idcnum_),
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, isprefix_),
  PROTOBUF_FIELD_OFFSET(::CheckTfsinfo, datalist_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, keyhash_),
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, keyrange_),
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, datasize_),
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, offset_),
  PROTOBUF_FIELD_OFFSET(::CosLavaDBIndex, ctime_),
  0,
  1,
  3,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, lavadb_cl5_modid_),
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, lavadb_cl5_cmid_),
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, lavadb_tid_),
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, lavadb_cid_),
  PROTOBUF_FIELD_OFFSET(::CheckLavaDBinfo, datalist_),
  0,
  1,
  2,
  3,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 13, sizeof(::ShaMainRecord)},
  { 21, 32, sizeof(::CasKeyRecord)},
  { 38, 52, sizeof(::PartRecord)},
  { 61, 74, sizeof(::CosDataIndex)},
  { 82, 95, sizeof(::CosDataIndexRsp)},
  { 103, 110, sizeof(::CosPartItem)},
  { 112, 119, sizeof(::CosPartdeleteItem)},
  { 121, 128, sizeof(::delstorinfo)},
  { 130, 149, sizeof(::storeinfo)},
  { 163, 173, sizeof(::cacheinfo)},
  { 178, 186, sizeof(::idcitem)},
  { 189, 197, sizeof(::sha1storeinfo)},
  { 200, 209, sizeof(::CosUploadCacheData)},
  { 213, 223, sizeof(::CosTfsIndex)},
  { 228, 238, sizeof(::CheckTfsinfo)},
  { 243, 253, sizeof(::CosLavaDBIndex)},
  { 258, 268, sizeof(::CheckLavaDBinfo)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ShaMainRecord_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CasKeyRecord_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_PartRecord_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosDataIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosDataIndexRsp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosPartItem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosPartdeleteItem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_delstorinfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_storeinfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_cacheinfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_idcitem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_sha1storeinfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosUploadCacheData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosTfsIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CheckTfsinfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CosLavaDBIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CheckLavaDBinfo_default_instance_),
};

const char descriptor_table_protodef_cos_5fcomm_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016cos_comm.proto\"\225\001\n\rShaMainRecord\022\013\n\003re"
  "f\030\001 \002(\r\022\r\n\005ctime\030\002 \002(\r\022\r\n\005mtime\030\003 \002(\r\022\r\n"
  "\005fsize\030\004 \002(\004\022\017\n\007hitflag\030\005 \002(\010\022\014\n\004type\030\007 "
  "\001(\r\022\031\n\007idclist\030\010 \003(\0132\010.idcitem\022\020\n\010is_chu"
  "nk\030\t \001(\010\"j\n\014CasKeyRecord\022\013\n\003ref\030\001 \002(\r\022\r\n"
  "\005ctime\030\002 \002(\r\022\r\n\005mtime\030\003 \002(\r\022\r\n\005fsize\030\004 \002"
  "(\004\022\022\n\narchive_id\030\005 \002(\014\022\014\n\004type\030\006 \001(\r\"\241\001\n"
  "\nPartRecord\022\013\n\003sha\030\001 \002(\014\022\r\n\005fsize\030\002 \002(\004\022"
  "\022\n\nisfinished\030\003 \002(\010\022\r\n\005ctime\030\004 \002(\r\022\021\n\006of"
  "fset\030\005 \001(\004:\0010\022\r\n\002id\030\006 \001(\r:\0010\022\r\n\005mtime\030\007 "
  "\001(\r\022\021\n\tslicesize\030\010 \001(\r\022\020\n\010real_sha\030\t \001(\014"
  "\"\217\001\n\014CosDataIndex\022\014\n\004chid\030\001 \001(\r\022\013\n\003fid\030\002"
  " \001(\r\022\020\n\010datasize\030\003 \001(\r\022\016\n\006offset\030\004 \001(\004\022\r"
  "\n\005ctime\030\005 \001(\r\022\020\n\010dataflag\030\006 \001(\t\022\017\n\007crc_n"
  "um\030\007 \001(\r\022\020\n\010cachekey\030\010 \001(\014\"\224\001\n\017CosDataIn"
  "dexRsp\022\017\n\007datakey\030\001 \001(\014\022\017\n\007version\030\002 \001(\014"
  "\022\014\n\004chid\030\003 \001(\r\022\013\n\003fid\030\004 \001(\r\022\017\n\007storeid\030\007"
  " \001(\r\022\020\n\010datasize\030\010 \001(\r\022\017\n\007crc_num\030\t \001(\r\022"
  "\020\n\010cachekey\030\n \001(\014\"+\n\013CosPartItem\022\017\n\007part"
  "num\030\001 \002(\r\022\013\n\003sha\030\002 \002(\014\"2\n\021CosPartdeleteI"
  "tem\022\020\n\010isfinish\030\001 \002(\010\022\013\n\003sha\030\002 \002(\014\"3\n\013de"
  "lstorinfo\022\030\n\004info\030\001 \001(\0132\n.storeinfo\022\n\n\002i"
  "d\030\002 \001(\r\"\271\002\n\tstoreinfo\022\025\n\rtfs_cl5_modid\030\001"
  " \001(\r\022\024\n\014tfs_cl5_cmid\030\002 \001(\r\022\030\n\020lavadb_cl5"
  "_modid\030\003 \001(\r\022\027\n\017lavadb_cl5_cmid\030\004 \001(\r\022\022\n"
  "\nlavadb_tid\030\005 \001(\r\022\022\n\nlavadb_cid\030\006 \001(\r\022\016\n"
  "\006idcnum\030\007 \001(\r\022\020\n\010isprefix\030\010 \001(\010\022\023\n\013isuse"
  "tfscl5\030\t \001(\r\022\032\n\022use_local_tfsproxy\030\n \001(\010"
  "\022\014\n\004name\030\013 \001(\014\022\021\n\tuse_cache\030\014 \001(\010\022\027\n\017cac"
  "he_cl5_modid\030\r \001(\r\022\027\n\017cache_cl5_cmdid\030\016 "
  "\001(\r\"w\n\tcacheinfo\022\030\n\020lavadb_cl5_modid\030\001 \001"
  "(\r\022\030\n\020lavadb_cl5_cmdid\030\002 \001(\r\022\022\n\nlavadb_t"
  "id\030\003 \001(\r\022\022\n\nlavadb_cid\030\004 \001(\r\022\016\n\006idcnum\030\005"
  " \001(\r\":\n\007idcitem\022\013\n\003idc\030\001 \002(\r\022\r\n\005ctime\030\002 "
  "\002(\r\022\023\n\013uploadstate\030\003 \002(\r\"V\n\rsha1storeinf"
  "o\022\013\n\003sha\030\001 \001(\014\022\030\n\004info\030\002 \001(\0132\n.storeinfo"
  "\022\036\n\ncache_info\030\003 \001(\0132\n.cacheinfo\"T\n\022CosU"
  "ploadCacheData\022\020\n\010datasize\030\001 \001(\r\022\016\n\006offs"
  "et\030\002 \001(\004\022\r\n\005ctime\030\003 \001(\r\022\r\n\005value\030\004 \001(\014\"Y"
  "\n\013CosTfsIndex\022\014\n\004chid\030\001 \001(\r\022\013\n\003fid\030\002 \001(\r"
  "\022\020\n\010datasize\030\003 \001(\r\022\016\n\006offset\030\004 \001(\004\022\r\n\005ct"
  "ime\030\005 \001(\r\"}\n\014CheckTfsinfo\022\025\n\rtfs_cl5_mod"
  "id\030\001 \001(\r\022\024\n\014tfs_cl5_cmid\030\002 \001(\r\022\016\n\006idcnum"
  "\030\003 \001(\r\022\020\n\010isprefix\030\004 \001(\010\022\036\n\010datalist\030\005 \003"
  "(\0132\014.CosTfsIndex\"d\n\016CosLavaDBIndex\022\017\n\007ke"
  "yhash\030\001 \001(\014\022\020\n\010keyrange\030\002 \001(\014\022\020\n\010datasiz"
  "e\030\003 \001(\r\022\016\n\006offset\030\004 \001(\004\022\r\n\005ctime\030\005 \001(\r\"\217"
  "\001\n\017CheckLavaDBinfo\022\030\n\020lavadb_cl5_modid\030\001"
  " \001(\r\022\027\n\017lavadb_cl5_cmid\030\002 \001(\r\022\022\n\nlavadb_"
  "tid\030\003 \001(\r\022\022\n\nlavadb_cid\030\004 \001(\r\022!\n\010datalis"
  "t\030\005 \003(\0132\017.CosLavaDBIndex*/\n\016cos_store_ty"
  "pe\022\014\n\010Standard\020\000\022\017\n\013Standard_IA\020\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_cos_5fcomm_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_cos_5fcomm_2eproto_sccs[17] = {
  &scc_info_CasKeyRecord_cos_5fcomm_2eproto.base,
  &scc_info_CheckLavaDBinfo_cos_5fcomm_2eproto.base,
  &scc_info_CheckTfsinfo_cos_5fcomm_2eproto.base,
  &scc_info_CosDataIndex_cos_5fcomm_2eproto.base,
  &scc_info_CosDataIndexRsp_cos_5fcomm_2eproto.base,
  &scc_info_CosLavaDBIndex_cos_5fcomm_2eproto.base,
  &scc_info_CosPartItem_cos_5fcomm_2eproto.base,
  &scc_info_CosPartdeleteItem_cos_5fcomm_2eproto.base,
  &scc_info_CosTfsIndex_cos_5fcomm_2eproto.base,
  &scc_info_CosUploadCacheData_cos_5fcomm_2eproto.base,
  &scc_info_PartRecord_cos_5fcomm_2eproto.base,
  &scc_info_ShaMainRecord_cos_5fcomm_2eproto.base,
  &scc_info_cacheinfo_cos_5fcomm_2eproto.base,
  &scc_info_delstorinfo_cos_5fcomm_2eproto.base,
  &scc_info_idcitem_cos_5fcomm_2eproto.base,
  &scc_info_sha1storeinfo_cos_5fcomm_2eproto.base,
  &scc_info_storeinfo_cos_5fcomm_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_cos_5fcomm_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cos_5fcomm_2eproto = {
  false, false, descriptor_table_protodef_cos_5fcomm_2eproto, "cos_comm.proto", 2073,
  &descriptor_table_cos_5fcomm_2eproto_once, descriptor_table_cos_5fcomm_2eproto_sccs, descriptor_table_cos_5fcomm_2eproto_deps, 17, 0,
  schemas, file_default_instances, TableStruct_cos_5fcomm_2eproto::offsets,
  file_level_metadata_cos_5fcomm_2eproto, 17, file_level_enum_descriptors_cos_5fcomm_2eproto, file_level_service_descriptors_cos_5fcomm_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_cos_5fcomm_2eproto(&descriptor_table_cos_5fcomm_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* cos_store_type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cos_5fcomm_2eproto);
  return file_level_enum_descriptors_cos_5fcomm_2eproto[0];
}
bool cos_store_type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ShaMainRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<ShaMainRecord>()._has_bits_);
  static void set_has_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mtime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_fsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hitflag(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000002f) ^ 0x0000002f) != 0;
  }
};

ShaMainRecord::ShaMainRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  idclist_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:ShaMainRecord)
}
ShaMainRecord::ShaMainRecord(const ShaMainRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      idclist_(from.idclist_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ref_, &from.ref_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_chunk_) -
    reinterpret_cast<char*>(&ref_)) + sizeof(is_chunk_));
  // @@protoc_insertion_point(copy_constructor:ShaMainRecord)
}

void ShaMainRecord::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ShaMainRecord_cos_5fcomm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&ref_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&is_chunk_) -
      reinterpret_cast<char*>(&ref_)) + sizeof(is_chunk_));
}

ShaMainRecord::~ShaMainRecord() {
  // @@protoc_insertion_point(destructor:ShaMainRecord)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ShaMainRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ShaMainRecord::ArenaDtor(void* object) {
  ShaMainRecord* _this = reinterpret_cast< ShaMainRecord* >(object);
  (void)_this;
}
void ShaMainRecord::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ShaMainRecord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ShaMainRecord& ShaMainRecord::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ShaMainRecord_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void ShaMainRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:ShaMainRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  idclist_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&ref_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_chunk_) -
        reinterpret_cast<char*>(&ref_)) + sizeof(is_chunk_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShaMainRecord::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ref(&has_bits);
          ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ctime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 mtime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_mtime(&has_bits);
          mtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 fsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_fsize(&has_bits);
          fsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool hitflag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_hitflag(&has_bits);
          hitflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .idcitem idclist = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_idclist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool is_chunk = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_chunk(&has_bits);
          is_chunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ShaMainRecord::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShaMainRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 ref = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ref(), target);
  }

  // required uint32 ctime = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ctime(), target);
  }

  // required uint32 mtime = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mtime(), target);
  }

  // required uint64 fsize = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_fsize(), target);
  }

  // required bool hitflag = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_hitflag(), target);
  }

  // optional uint32 type = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_type(), target);
  }

  // repeated .idcitem idclist = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_idclist_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_idclist(i), target, stream);
  }

  // optional bool is_chunk = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_chunk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShaMainRecord)
  return target;
}

size_t ShaMainRecord::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ShaMainRecord)
  size_t total_size = 0;

  if (_internal_has_ref()) {
    // required uint32 ref = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ref());
  }

  if (_internal_has_ctime()) {
    // required uint32 ctime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());
  }

  if (_internal_has_fsize()) {
    // required uint64 fsize = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_fsize());
  }

  if (_internal_has_mtime()) {
    // required uint32 mtime = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_mtime());
  }

  if (_internal_has_hitflag()) {
    // required bool hitflag = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t ShaMainRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ShaMainRecord)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000002f) ^ 0x0000002f) == 0) {  // All required fields are present.
    // required uint32 ref = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ref());

    // required uint32 ctime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());

    // required uint64 fsize = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_fsize());

    // required uint32 mtime = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_mtime());

    // required bool hitflag = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .idcitem idclist = 8;
  total_size += 1UL * this->_internal_idclist_size();
  for (const auto& msg : this->idclist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 type = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_type());
  }

  // optional bool is_chunk = 9;
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShaMainRecord::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ShaMainRecord)
  GOOGLE_DCHECK_NE(&from, this);
  const ShaMainRecord* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ShaMainRecord>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ShaMainRecord)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ShaMainRecord)
    MergeFrom(*source);
  }
}

void ShaMainRecord::MergeFrom(const ShaMainRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ShaMainRecord)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  idclist_.MergeFrom(from.idclist_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ref_ = from.ref_;
    }
    if (cached_has_bits & 0x00000002u) {
      ctime_ = from.ctime_;
    }
    if (cached_has_bits & 0x00000004u) {
      fsize_ = from.fsize_;
    }
    if (cached_has_bits & 0x00000008u) {
      mtime_ = from.mtime_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      hitflag_ = from.hitflag_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_chunk_ = from.is_chunk_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ShaMainRecord::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ShaMainRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShaMainRecord::CopyFrom(const ShaMainRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ShaMainRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShaMainRecord::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(idclist_)) return false;
  return true;
}

void ShaMainRecord::InternalSwap(ShaMainRecord* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  idclist_.InternalSwap(&other->idclist_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShaMainRecord, is_chunk_)
      + sizeof(ShaMainRecord::is_chunk_)
      - PROTOBUF_FIELD_OFFSET(ShaMainRecord, ref_)>(
          reinterpret_cast<char*>(&ref_),
          reinterpret_cast<char*>(&other->ref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShaMainRecord::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CasKeyRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<CasKeyRecord>()._has_bits_);
  static void set_has_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mtime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fsize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_archive_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

CasKeyRecord::CasKeyRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CasKeyRecord)
}
CasKeyRecord::CasKeyRecord(const CasKeyRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  archive_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_archive_id()) {
    archive_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_archive_id(), 
      GetArena());
  }
  ::memcpy(&ref_, &from.ref_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&ref_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:CasKeyRecord)
}

void CasKeyRecord::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CasKeyRecord_cos_5fcomm_2eproto.base);
  archive_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&ref_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&ref_)) + sizeof(type_));
}

CasKeyRecord::~CasKeyRecord() {
  // @@protoc_insertion_point(destructor:CasKeyRecord)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CasKeyRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  archive_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CasKeyRecord::ArenaDtor(void* object) {
  CasKeyRecord* _this = reinterpret_cast< CasKeyRecord* >(object);
  (void)_this;
}
void CasKeyRecord::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CasKeyRecord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CasKeyRecord& CasKeyRecord::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CasKeyRecord_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CasKeyRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:CasKeyRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    archive_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&ref_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&ref_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CasKeyRecord::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ref(&has_bits);
          ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ctime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 mtime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_mtime(&has_bits);
          mtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 fsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_fsize(&has_bits);
          fsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes archive_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_archive_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CasKeyRecord::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CasKeyRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 ref = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ref(), target);
  }

  // required uint32 ctime = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ctime(), target);
  }

  // required uint32 mtime = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_mtime(), target);
  }

  // required uint64 fsize = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_fsize(), target);
  }

  // required bytes archive_id = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_archive_id(), target);
  }

  // optional uint32 type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CasKeyRecord)
  return target;
}

size_t CasKeyRecord::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CasKeyRecord)
  size_t total_size = 0;

  if (_internal_has_archive_id()) {
    // required bytes archive_id = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_archive_id());
  }

  if (_internal_has_ref()) {
    // required uint32 ref = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ref());
  }

  if (_internal_has_ctime()) {
    // required uint32 ctime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());
  }

  if (_internal_has_fsize()) {
    // required uint64 fsize = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_fsize());
  }

  if (_internal_has_mtime()) {
    // required uint32 mtime = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_mtime());
  }

  return total_size;
}
size_t CasKeyRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CasKeyRecord)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required bytes archive_id = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_archive_id());

    // required uint32 ref = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ref());

    // required uint32 ctime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());

    // required uint64 fsize = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_fsize());

    // required uint32 mtime = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_mtime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 type = 6;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000020u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CasKeyRecord::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CasKeyRecord)
  GOOGLE_DCHECK_NE(&from, this);
  const CasKeyRecord* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CasKeyRecord>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CasKeyRecord)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CasKeyRecord)
    MergeFrom(*source);
  }
}

void CasKeyRecord::MergeFrom(const CasKeyRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CasKeyRecord)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_archive_id(from._internal_archive_id());
    }
    if (cached_has_bits & 0x00000002u) {
      ref_ = from.ref_;
    }
    if (cached_has_bits & 0x00000004u) {
      ctime_ = from.ctime_;
    }
    if (cached_has_bits & 0x00000008u) {
      fsize_ = from.fsize_;
    }
    if (cached_has_bits & 0x00000010u) {
      mtime_ = from.mtime_;
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CasKeyRecord::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CasKeyRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CasKeyRecord::CopyFrom(const CasKeyRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CasKeyRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CasKeyRecord::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CasKeyRecord::InternalSwap(CasKeyRecord* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  archive_id_.Swap(&other->archive_id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CasKeyRecord, type_)
      + sizeof(CasKeyRecord::type_)
      - PROTOBUF_FIELD_OFFSET(CasKeyRecord, ref_)>(
          reinterpret_cast<char*>(&ref_),
          reinterpret_cast<char*>(&other->ref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CasKeyRecord::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class PartRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<PartRecord>()._has_bits_);
  static void set_has_sha(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_isfinished(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_mtime(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_slicesize(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_real_sha(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001d) ^ 0x0000001d) != 0;
  }
};

PartRecord::PartRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:PartRecord)
}
PartRecord::PartRecord(const PartRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sha()) {
    sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sha(), 
      GetArena());
  }
  real_sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_real_sha()) {
    real_sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_real_sha(), 
      GetArena());
  }
  ::memcpy(&fsize_, &from.fsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&slicesize_) -
    reinterpret_cast<char*>(&fsize_)) + sizeof(slicesize_));
  // @@protoc_insertion_point(copy_constructor:PartRecord)
}

void PartRecord::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PartRecord_cos_5fcomm_2eproto.base);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  real_sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&fsize_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&slicesize_) -
      reinterpret_cast<char*>(&fsize_)) + sizeof(slicesize_));
}

PartRecord::~PartRecord() {
  // @@protoc_insertion_point(destructor:PartRecord)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PartRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  sha_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  real_sha_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PartRecord::ArenaDtor(void* object) {
  PartRecord* _this = reinterpret_cast< PartRecord* >(object);
  (void)_this;
}
void PartRecord::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PartRecord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PartRecord& PartRecord::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PartRecord_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void PartRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:PartRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sha_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      real_sha_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&fsize_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mtime_) -
        reinterpret_cast<char*>(&fsize_)) + sizeof(mtime_));
  }
  slicesize_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartRecord::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes sha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_sha();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 fsize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_fsize(&has_bits);
          fsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool isfinished = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_isfinished(&has_bits);
          isfinished_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ctime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 id = 6 [default = 0];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mtime = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_mtime(&has_bits);
          mtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 slicesize = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_slicesize(&has_bits);
          slicesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes real_sha = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_real_sha();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PartRecord::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PartRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes sha = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_sha(), target);
  }

  // required uint64 fsize = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_fsize(), target);
  }

  // required bool isfinished = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isfinished(), target);
  }

  // required uint32 ctime = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ctime(), target);
  }

  // optional uint64 offset = 5 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_offset(), target);
  }

  // optional uint32 id = 6 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_id(), target);
  }

  // optional uint32 mtime = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_mtime(), target);
  }

  // optional uint32 slicesize = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_slicesize(), target);
  }

  // optional bytes real_sha = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_real_sha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PartRecord)
  return target;
}

size_t PartRecord::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PartRecord)
  size_t total_size = 0;

  if (_internal_has_sha()) {
    // required bytes sha = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha());
  }

  if (_internal_has_fsize()) {
    // required uint64 fsize = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_fsize());
  }

  if (_internal_has_isfinished()) {
    // required bool isfinished = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_ctime()) {
    // required uint32 ctime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());
  }

  return total_size;
}
size_t PartRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PartRecord)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001d) ^ 0x0000001d) == 0) {  // All required fields are present.
    // required bytes sha = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha());

    // required uint64 fsize = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_fsize());

    // required bool isfinished = 3;
    total_size += 1 + 1;

    // required uint32 ctime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes real_sha = 9;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_real_sha());
  }

  if (cached_has_bits & 0x000000e0u) {
    // optional uint64 offset = 5 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_offset());
    }

    // optional uint32 id = 6 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_id());
    }

    // optional uint32 mtime = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mtime());
    }

  }
  // optional uint32 slicesize = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_slicesize());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PartRecord::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:PartRecord)
  GOOGLE_DCHECK_NE(&from, this);
  const PartRecord* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PartRecord>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:PartRecord)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:PartRecord)
    MergeFrom(*source);
  }
}

void PartRecord::MergeFrom(const PartRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PartRecord)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sha(from._internal_sha());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_real_sha(from._internal_real_sha());
    }
    if (cached_has_bits & 0x00000004u) {
      fsize_ = from.fsize_;
    }
    if (cached_has_bits & 0x00000008u) {
      isfinished_ = from.isfinished_;
    }
    if (cached_has_bits & 0x00000010u) {
      ctime_ = from.ctime_;
    }
    if (cached_has_bits & 0x00000020u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000040u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000080u) {
      mtime_ = from.mtime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_slicesize(from._internal_slicesize());
  }
}

void PartRecord::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:PartRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PartRecord::CopyFrom(const PartRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PartRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartRecord::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PartRecord::InternalSwap(PartRecord* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sha_.Swap(&other->sha_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  real_sha_.Swap(&other->real_sha_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PartRecord, slicesize_)
      + sizeof(PartRecord::slicesize_)
      - PROTOBUF_FIELD_OFFSET(PartRecord, fsize_)>(
          reinterpret_cast<char*>(&fsize_),
          reinterpret_cast<char*>(&other->fsize_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PartRecord::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosDataIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<CosDataIndex>()._has_bits_);
  static void set_has_chid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_datasize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_dataflag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_crc_num(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cachekey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CosDataIndex::CosDataIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosDataIndex)
}
CosDataIndex::CosDataIndex(const CosDataIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  dataflag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_dataflag()) {
    dataflag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_dataflag(), 
      GetArena());
  }
  cachekey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cachekey()) {
    cachekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cachekey(), 
      GetArena());
  }
  ::memcpy(&chid_, &from.chid_,
    static_cast<size_t>(reinterpret_cast<char*>(&crc_num_) -
    reinterpret_cast<char*>(&chid_)) + sizeof(crc_num_));
  // @@protoc_insertion_point(copy_constructor:CosDataIndex)
}

void CosDataIndex::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CosDataIndex_cos_5fcomm_2eproto.base);
  dataflag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cachekey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&chid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&crc_num_) -
      reinterpret_cast<char*>(&chid_)) + sizeof(crc_num_));
}

CosDataIndex::~CosDataIndex() {
  // @@protoc_insertion_point(destructor:CosDataIndex)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosDataIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  dataflag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cachekey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CosDataIndex::ArenaDtor(void* object) {
  CosDataIndex* _this = reinterpret_cast< CosDataIndex* >(object);
  (void)_this;
}
void CosDataIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosDataIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosDataIndex& CosDataIndex::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosDataIndex_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosDataIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:CosDataIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      dataflag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      cachekey_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&chid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&crc_num_) -
        reinterpret_cast<char*>(&chid_)) + sizeof(crc_num_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosDataIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 chid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_chid(&has_bits);
          chid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 fid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_fid(&has_bits);
          fid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datasize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_datasize(&has_bits);
          datasize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ctime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string dataflag = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_dataflag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CosDataIndex.dataflag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 crc_num = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_crc_num(&has_bits);
          crc_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes cachekey = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_cachekey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosDataIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosDataIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 chid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_chid(), target);
  }

  // optional uint32 fid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fid(), target);
  }

  // optional uint32 datasize = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_datasize(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional uint32 ctime = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ctime(), target);
  }

  // optional string dataflag = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dataflag().data(), static_cast<int>(this->_internal_dataflag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CosDataIndex.dataflag");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_dataflag(), target);
  }

  // optional uint32 crc_num = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_crc_num(), target);
  }

  // optional bytes cachekey = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_cachekey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosDataIndex)
  return target;
}

size_t CosDataIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosDataIndex)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string dataflag = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dataflag());
    }

    // optional bytes cachekey = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cachekey());
    }

    // optional uint32 chid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_chid());
    }

    // optional uint32 fid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_fid());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_offset());
    }

    // optional uint32 datasize = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datasize());
    }

    // optional uint32 ctime = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ctime());
    }

    // optional uint32 crc_num = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_crc_num());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosDataIndex::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosDataIndex)
  GOOGLE_DCHECK_NE(&from, this);
  const CosDataIndex* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosDataIndex>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosDataIndex)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosDataIndex)
    MergeFrom(*source);
  }
}

void CosDataIndex::MergeFrom(const CosDataIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosDataIndex)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_dataflag(from._internal_dataflag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_cachekey(from._internal_cachekey());
    }
    if (cached_has_bits & 0x00000004u) {
      chid_ = from.chid_;
    }
    if (cached_has_bits & 0x00000008u) {
      fid_ = from.fid_;
    }
    if (cached_has_bits & 0x00000010u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000020u) {
      datasize_ = from.datasize_;
    }
    if (cached_has_bits & 0x00000040u) {
      ctime_ = from.ctime_;
    }
    if (cached_has_bits & 0x00000080u) {
      crc_num_ = from.crc_num_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosDataIndex::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosDataIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosDataIndex::CopyFrom(const CosDataIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosDataIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosDataIndex::IsInitialized() const {
  return true;
}

void CosDataIndex::InternalSwap(CosDataIndex* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dataflag_.Swap(&other->dataflag_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  cachekey_.Swap(&other->cachekey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CosDataIndex, crc_num_)
      + sizeof(CosDataIndex::crc_num_)
      - PROTOBUF_FIELD_OFFSET(CosDataIndex, chid_)>(
          reinterpret_cast<char*>(&chid_),
          reinterpret_cast<char*>(&other->chid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CosDataIndex::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosDataIndexRsp::_Internal {
 public:
  using HasBits = decltype(std::declval<CosDataIndexRsp>()._has_bits_);
  static void set_has_datakey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_fid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_storeid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_datasize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_crc_num(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cachekey(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CosDataIndexRsp::CosDataIndexRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosDataIndexRsp)
}
CosDataIndexRsp::CosDataIndexRsp(const CosDataIndexRsp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  datakey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_datakey()) {
    datakey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_datakey(), 
      GetArena());
  }
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_version()) {
    version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version(), 
      GetArena());
  }
  cachekey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cachekey()) {
    cachekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cachekey(), 
      GetArena());
  }
  ::memcpy(&chid_, &from.chid_,
    static_cast<size_t>(reinterpret_cast<char*>(&crc_num_) -
    reinterpret_cast<char*>(&chid_)) + sizeof(crc_num_));
  // @@protoc_insertion_point(copy_constructor:CosDataIndexRsp)
}

void CosDataIndexRsp::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CosDataIndexRsp_cos_5fcomm_2eproto.base);
  datakey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cachekey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&chid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&crc_num_) -
      reinterpret_cast<char*>(&chid_)) + sizeof(crc_num_));
}

CosDataIndexRsp::~CosDataIndexRsp() {
  // @@protoc_insertion_point(destructor:CosDataIndexRsp)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosDataIndexRsp::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  datakey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cachekey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CosDataIndexRsp::ArenaDtor(void* object) {
  CosDataIndexRsp* _this = reinterpret_cast< CosDataIndexRsp* >(object);
  (void)_this;
}
void CosDataIndexRsp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosDataIndexRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosDataIndexRsp& CosDataIndexRsp::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosDataIndexRsp_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosDataIndexRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:CosDataIndexRsp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      datakey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      cachekey_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&chid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&crc_num_) -
        reinterpret_cast<char*>(&chid_)) + sizeof(crc_num_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosDataIndexRsp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes datakey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_datakey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 chid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_chid(&has_bits);
          chid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 fid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_fid(&has_bits);
          fid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 storeid = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_storeid(&has_bits);
          storeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datasize = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_datasize(&has_bits);
          datasize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 crc_num = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_crc_num(&has_bits);
          crc_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes cachekey = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_cachekey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosDataIndexRsp::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosDataIndexRsp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes datakey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_datakey(), target);
  }

  // optional bytes version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_version(), target);
  }

  // optional uint32 chid = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_chid(), target);
  }

  // optional uint32 fid = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_fid(), target);
  }

  // optional uint32 storeid = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_storeid(), target);
  }

  // optional uint32 datasize = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_datasize(), target);
  }

  // optional uint32 crc_num = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_crc_num(), target);
  }

  // optional bytes cachekey = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_cachekey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosDataIndexRsp)
  return target;
}

size_t CosDataIndexRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosDataIndexRsp)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes datakey = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_datakey());
    }

    // optional bytes version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_version());
    }

    // optional bytes cachekey = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_cachekey());
    }

    // optional uint32 chid = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_chid());
    }

    // optional uint32 fid = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_fid());
    }

    // optional uint32 storeid = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_storeid());
    }

    // optional uint32 datasize = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datasize());
    }

    // optional uint32 crc_num = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_crc_num());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosDataIndexRsp::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosDataIndexRsp)
  GOOGLE_DCHECK_NE(&from, this);
  const CosDataIndexRsp* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosDataIndexRsp>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosDataIndexRsp)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosDataIndexRsp)
    MergeFrom(*source);
  }
}

void CosDataIndexRsp::MergeFrom(const CosDataIndexRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosDataIndexRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_datakey(from._internal_datakey());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_cachekey(from._internal_cachekey());
    }
    if (cached_has_bits & 0x00000008u) {
      chid_ = from.chid_;
    }
    if (cached_has_bits & 0x00000010u) {
      fid_ = from.fid_;
    }
    if (cached_has_bits & 0x00000020u) {
      storeid_ = from.storeid_;
    }
    if (cached_has_bits & 0x00000040u) {
      datasize_ = from.datasize_;
    }
    if (cached_has_bits & 0x00000080u) {
      crc_num_ = from.crc_num_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosDataIndexRsp::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosDataIndexRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosDataIndexRsp::CopyFrom(const CosDataIndexRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosDataIndexRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosDataIndexRsp::IsInitialized() const {
  return true;
}

void CosDataIndexRsp::InternalSwap(CosDataIndexRsp* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  datakey_.Swap(&other->datakey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  version_.Swap(&other->version_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  cachekey_.Swap(&other->cachekey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CosDataIndexRsp, crc_num_)
      + sizeof(CosDataIndexRsp::crc_num_)
      - PROTOBUF_FIELD_OFFSET(CosDataIndexRsp, chid_)>(
          reinterpret_cast<char*>(&chid_),
          reinterpret_cast<char*>(&other->chid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CosDataIndexRsp::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosPartItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CosPartItem>()._has_bits_);
  static void set_has_partnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sha(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CosPartItem::CosPartItem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosPartItem)
}
CosPartItem::CosPartItem(const CosPartItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sha()) {
    sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sha(), 
      GetArena());
  }
  partnum_ = from.partnum_;
  // @@protoc_insertion_point(copy_constructor:CosPartItem)
}

void CosPartItem::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CosPartItem_cos_5fcomm_2eproto.base);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  partnum_ = 0u;
}

CosPartItem::~CosPartItem() {
  // @@protoc_insertion_point(destructor:CosPartItem)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosPartItem::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  sha_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CosPartItem::ArenaDtor(void* object) {
  CosPartItem* _this = reinterpret_cast< CosPartItem* >(object);
  (void)_this;
}
void CosPartItem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosPartItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosPartItem& CosPartItem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosPartItem_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosPartItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CosPartItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sha_.ClearNonDefaultToEmpty();
  }
  partnum_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosPartItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 partnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_partnum(&has_bits);
          partnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes sha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_sha();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosPartItem::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosPartItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 partnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_partnum(), target);
  }

  // required bytes sha = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosPartItem)
  return target;
}

size_t CosPartItem::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CosPartItem)
  size_t total_size = 0;

  if (_internal_has_sha()) {
    // required bytes sha = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha());
  }

  if (_internal_has_partnum()) {
    // required uint32 partnum = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_partnum());
  }

  return total_size;
}
size_t CosPartItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosPartItem)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes sha = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha());

    // required uint32 partnum = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_partnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosPartItem::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosPartItem)
  GOOGLE_DCHECK_NE(&from, this);
  const CosPartItem* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosPartItem>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosPartItem)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosPartItem)
    MergeFrom(*source);
  }
}

void CosPartItem::MergeFrom(const CosPartItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosPartItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sha(from._internal_sha());
    }
    if (cached_has_bits & 0x00000002u) {
      partnum_ = from.partnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosPartItem::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosPartItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosPartItem::CopyFrom(const CosPartItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosPartItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosPartItem::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CosPartItem::InternalSwap(CosPartItem* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sha_.Swap(&other->sha_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(partnum_, other->partnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CosPartItem::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosPartdeleteItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CosPartdeleteItem>()._has_bits_);
  static void set_has_isfinish(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sha(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CosPartdeleteItem::CosPartdeleteItem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosPartdeleteItem)
}
CosPartdeleteItem::CosPartdeleteItem(const CosPartdeleteItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sha()) {
    sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sha(), 
      GetArena());
  }
  isfinish_ = from.isfinish_;
  // @@protoc_insertion_point(copy_constructor:CosPartdeleteItem)
}

void CosPartdeleteItem::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CosPartdeleteItem_cos_5fcomm_2eproto.base);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  isfinish_ = false;
}

CosPartdeleteItem::~CosPartdeleteItem() {
  // @@protoc_insertion_point(destructor:CosPartdeleteItem)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosPartdeleteItem::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  sha_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CosPartdeleteItem::ArenaDtor(void* object) {
  CosPartdeleteItem* _this = reinterpret_cast< CosPartdeleteItem* >(object);
  (void)_this;
}
void CosPartdeleteItem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosPartdeleteItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosPartdeleteItem& CosPartdeleteItem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosPartdeleteItem_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosPartdeleteItem::Clear() {
// @@protoc_insertion_point(message_clear_start:CosPartdeleteItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sha_.ClearNonDefaultToEmpty();
  }
  isfinish_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosPartdeleteItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool isfinish = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_isfinish(&has_bits);
          isfinish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes sha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_sha();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosPartdeleteItem::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosPartdeleteItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool isfinish = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_isfinish(), target);
  }

  // required bytes sha = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosPartdeleteItem)
  return target;
}

size_t CosPartdeleteItem::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CosPartdeleteItem)
  size_t total_size = 0;

  if (_internal_has_sha()) {
    // required bytes sha = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha());
  }

  if (_internal_has_isfinish()) {
    // required bool isfinish = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CosPartdeleteItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosPartdeleteItem)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes sha = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha());

    // required bool isfinish = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosPartdeleteItem::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosPartdeleteItem)
  GOOGLE_DCHECK_NE(&from, this);
  const CosPartdeleteItem* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosPartdeleteItem>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosPartdeleteItem)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosPartdeleteItem)
    MergeFrom(*source);
  }
}

void CosPartdeleteItem::MergeFrom(const CosPartdeleteItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosPartdeleteItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sha(from._internal_sha());
    }
    if (cached_has_bits & 0x00000002u) {
      isfinish_ = from.isfinish_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosPartdeleteItem::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosPartdeleteItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosPartdeleteItem::CopyFrom(const CosPartdeleteItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosPartdeleteItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosPartdeleteItem::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CosPartdeleteItem::InternalSwap(CosPartdeleteItem* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sha_.Swap(&other->sha_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(isfinish_, other->isfinish_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CosPartdeleteItem::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class delstorinfo::_Internal {
 public:
  using HasBits = decltype(std::declval<delstorinfo>()._has_bits_);
  static const ::storeinfo& info(const delstorinfo* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::storeinfo&
delstorinfo::_Internal::info(const delstorinfo* msg) {
  return *msg->info_;
}
delstorinfo::delstorinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:delstorinfo)
}
delstorinfo::delstorinfo(const delstorinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::storeinfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:delstorinfo)
}

void delstorinfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_delstorinfo_cos_5fcomm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&info_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&info_)) + sizeof(id_));
}

delstorinfo::~delstorinfo() {
  // @@protoc_insertion_point(destructor:delstorinfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void delstorinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete info_;
}

void delstorinfo::ArenaDtor(void* object) {
  delstorinfo* _this = reinterpret_cast< delstorinfo* >(object);
  (void)_this;
}
void delstorinfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void delstorinfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const delstorinfo& delstorinfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_delstorinfo_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void delstorinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:delstorinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* delstorinfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .storeinfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* delstorinfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:delstorinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .storeinfo info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::info(this), target, stream);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:delstorinfo)
  return target;
}

size_t delstorinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:delstorinfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .storeinfo info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void delstorinfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:delstorinfo)
  GOOGLE_DCHECK_NE(&from, this);
  const delstorinfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<delstorinfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:delstorinfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:delstorinfo)
    MergeFrom(*source);
  }
}

void delstorinfo::MergeFrom(const delstorinfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:delstorinfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_info()->::storeinfo::MergeFrom(from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void delstorinfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:delstorinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void delstorinfo::CopyFrom(const delstorinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:delstorinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool delstorinfo::IsInitialized() const {
  return true;
}

void delstorinfo::InternalSwap(delstorinfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(delstorinfo, id_)
      + sizeof(delstorinfo::id_)
      - PROTOBUF_FIELD_OFFSET(delstorinfo, info_)>(
          reinterpret_cast<char*>(&info_),
          reinterpret_cast<char*>(&other->info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata delstorinfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class storeinfo::_Internal {
 public:
  using HasBits = decltype(std::declval<storeinfo>()._has_bits_);
  static void set_has_tfs_cl5_modid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tfs_cl5_cmid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lavadb_cl5_modid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lavadb_cl5_cmid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lavadb_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lavadb_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_idcnum(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_isprefix(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_isusetfscl5(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_use_local_tfsproxy(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_cache(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_cache_cl5_modid(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_cache_cl5_cmdid(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

storeinfo::storeinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:storeinfo)
}
storeinfo::storeinfo(const storeinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArena());
  }
  ::memcpy(&tfs_cl5_modid_, &from.tfs_cl5_modid_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_cl5_cmdid_) -
    reinterpret_cast<char*>(&tfs_cl5_modid_)) + sizeof(cache_cl5_cmdid_));
  // @@protoc_insertion_point(copy_constructor:storeinfo)
}

void storeinfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_storeinfo_cos_5fcomm_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&tfs_cl5_modid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&cache_cl5_cmdid_) -
      reinterpret_cast<char*>(&tfs_cl5_modid_)) + sizeof(cache_cl5_cmdid_));
}

storeinfo::~storeinfo() {
  // @@protoc_insertion_point(destructor:storeinfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void storeinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void storeinfo::ArenaDtor(void* object) {
  storeinfo* _this = reinterpret_cast< storeinfo* >(object);
  (void)_this;
}
void storeinfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void storeinfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const storeinfo& storeinfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_storeinfo_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void storeinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:storeinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&tfs_cl5_modid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&idcnum_) -
        reinterpret_cast<char*>(&tfs_cl5_modid_)) + sizeof(idcnum_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&isusetfscl5_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cache_cl5_cmdid_) -
        reinterpret_cast<char*>(&isusetfscl5_)) + sizeof(cache_cl5_cmdid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* storeinfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 tfs_cl5_modid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tfs_cl5_modid(&has_bits);
          tfs_cl5_modid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tfs_cl5_cmid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_tfs_cl5_cmid(&has_bits);
          tfs_cl5_cmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cl5_modid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lavadb_cl5_modid(&has_bits);
          lavadb_cl5_modid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cl5_cmid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lavadb_cl5_cmid(&has_bits);
          lavadb_cl5_cmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_tid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_lavadb_tid(&has_bits);
          lavadb_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_lavadb_cid(&has_bits);
          lavadb_cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 idcnum = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_idcnum(&has_bits);
          idcnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool isprefix = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_isprefix(&has_bits);
          isprefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 isusetfscl5 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_isusetfscl5(&has_bits);
          isusetfscl5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_local_tfsproxy = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_use_local_tfsproxy(&has_bits);
          use_local_tfsproxy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes name = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_cache = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_use_cache(&has_bits);
          use_cache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cache_cl5_modid = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_cache_cl5_modid(&has_bits);
          cache_cl5_modid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cache_cl5_cmdid = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_cache_cl5_cmdid(&has_bits);
          cache_cl5_cmdid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* storeinfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storeinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 tfs_cl5_modid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tfs_cl5_modid(), target);
  }

  // optional uint32 tfs_cl5_cmid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tfs_cl5_cmid(), target);
  }

  // optional uint32 lavadb_cl5_modid = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lavadb_cl5_modid(), target);
  }

  // optional uint32 lavadb_cl5_cmid = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lavadb_cl5_cmid(), target);
  }

  // optional uint32 lavadb_tid = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_lavadb_tid(), target);
  }

  // optional uint32 lavadb_cid = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_lavadb_cid(), target);
  }

  // optional uint32 idcnum = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_idcnum(), target);
  }

  // optional bool isprefix = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_isprefix(), target);
  }

  // optional uint32 isusetfscl5 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_isusetfscl5(), target);
  }

  // optional bool use_local_tfsproxy = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_use_local_tfsproxy(), target);
  }

  // optional bytes name = 11;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_name(), target);
  }

  // optional bool use_cache = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_use_cache(), target);
  }

  // optional uint32 cache_cl5_modid = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_cache_cl5_modid(), target);
  }

  // optional uint32 cache_cl5_cmdid = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->_internal_cache_cl5_cmdid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storeinfo)
  return target;
}

size_t storeinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storeinfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes name = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_name());
    }

    // optional uint32 tfs_cl5_modid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_tfs_cl5_modid());
    }

    // optional uint32 tfs_cl5_cmid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_tfs_cl5_cmid());
    }

    // optional uint32 lavadb_cl5_modid = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cl5_modid());
    }

    // optional uint32 lavadb_cl5_cmid = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cl5_cmid());
    }

    // optional uint32 lavadb_tid = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_tid());
    }

    // optional uint32 lavadb_cid = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cid());
    }

    // optional uint32 idcnum = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_idcnum());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 isusetfscl5 = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_isusetfscl5());
    }

    // optional bool isprefix = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool use_local_tfsproxy = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool use_cache = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional uint32 cache_cl5_modid = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_cache_cl5_modid());
    }

    // optional uint32 cache_cl5_cmdid = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_cache_cl5_cmdid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void storeinfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:storeinfo)
  GOOGLE_DCHECK_NE(&from, this);
  const storeinfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<storeinfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:storeinfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:storeinfo)
    MergeFrom(*source);
  }
}

void storeinfo::MergeFrom(const storeinfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storeinfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      tfs_cl5_modid_ = from.tfs_cl5_modid_;
    }
    if (cached_has_bits & 0x00000004u) {
      tfs_cl5_cmid_ = from.tfs_cl5_cmid_;
    }
    if (cached_has_bits & 0x00000008u) {
      lavadb_cl5_modid_ = from.lavadb_cl5_modid_;
    }
    if (cached_has_bits & 0x00000010u) {
      lavadb_cl5_cmid_ = from.lavadb_cl5_cmid_;
    }
    if (cached_has_bits & 0x00000020u) {
      lavadb_tid_ = from.lavadb_tid_;
    }
    if (cached_has_bits & 0x00000040u) {
      lavadb_cid_ = from.lavadb_cid_;
    }
    if (cached_has_bits & 0x00000080u) {
      idcnum_ = from.idcnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      isusetfscl5_ = from.isusetfscl5_;
    }
    if (cached_has_bits & 0x00000200u) {
      isprefix_ = from.isprefix_;
    }
    if (cached_has_bits & 0x00000400u) {
      use_local_tfsproxy_ = from.use_local_tfsproxy_;
    }
    if (cached_has_bits & 0x00000800u) {
      use_cache_ = from.use_cache_;
    }
    if (cached_has_bits & 0x00001000u) {
      cache_cl5_modid_ = from.cache_cl5_modid_;
    }
    if (cached_has_bits & 0x00002000u) {
      cache_cl5_cmdid_ = from.cache_cl5_cmdid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void storeinfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:storeinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void storeinfo::CopyFrom(const storeinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storeinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool storeinfo::IsInitialized() const {
  return true;
}

void storeinfo::InternalSwap(storeinfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(storeinfo, cache_cl5_cmdid_)
      + sizeof(storeinfo::cache_cl5_cmdid_)
      - PROTOBUF_FIELD_OFFSET(storeinfo, tfs_cl5_modid_)>(
          reinterpret_cast<char*>(&tfs_cl5_modid_),
          reinterpret_cast<char*>(&other->tfs_cl5_modid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata storeinfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class cacheinfo::_Internal {
 public:
  using HasBits = decltype(std::declval<cacheinfo>()._has_bits_);
  static void set_has_lavadb_cl5_modid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lavadb_cl5_cmdid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lavadb_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lavadb_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_idcnum(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

cacheinfo::cacheinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:cacheinfo)
}
cacheinfo::cacheinfo(const cacheinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&lavadb_cl5_modid_, &from.lavadb_cl5_modid_,
    static_cast<size_t>(reinterpret_cast<char*>(&idcnum_) -
    reinterpret_cast<char*>(&lavadb_cl5_modid_)) + sizeof(idcnum_));
  // @@protoc_insertion_point(copy_constructor:cacheinfo)
}

void cacheinfo::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&lavadb_cl5_modid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&idcnum_) -
      reinterpret_cast<char*>(&lavadb_cl5_modid_)) + sizeof(idcnum_));
}

cacheinfo::~cacheinfo() {
  // @@protoc_insertion_point(destructor:cacheinfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void cacheinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void cacheinfo::ArenaDtor(void* object) {
  cacheinfo* _this = reinterpret_cast< cacheinfo* >(object);
  (void)_this;
}
void cacheinfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void cacheinfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const cacheinfo& cacheinfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_cacheinfo_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void cacheinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cacheinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&lavadb_cl5_modid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&idcnum_) -
        reinterpret_cast<char*>(&lavadb_cl5_modid_)) + sizeof(idcnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* cacheinfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 lavadb_cl5_modid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_lavadb_cl5_modid(&has_bits);
          lavadb_cl5_modid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cl5_cmdid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lavadb_cl5_cmdid(&has_bits);
          lavadb_cl5_cmdid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_tid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lavadb_tid(&has_bits);
          lavadb_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lavadb_cid(&has_bits);
          lavadb_cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 idcnum = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_idcnum(&has_bits);
          idcnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* cacheinfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:cacheinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 lavadb_cl5_modid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_lavadb_cl5_modid(), target);
  }

  // optional uint32 lavadb_cl5_cmdid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavadb_cl5_cmdid(), target);
  }

  // optional uint32 lavadb_tid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lavadb_tid(), target);
  }

  // optional uint32 lavadb_cid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lavadb_cid(), target);
  }

  // optional uint32 idcnum = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_idcnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cacheinfo)
  return target;
}

size_t cacheinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:cacheinfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 lavadb_cl5_modid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cl5_modid());
    }

    // optional uint32 lavadb_cl5_cmdid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cl5_cmdid());
    }

    // optional uint32 lavadb_tid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_tid());
    }

    // optional uint32 lavadb_cid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cid());
    }

    // optional uint32 idcnum = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_idcnum());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void cacheinfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:cacheinfo)
  GOOGLE_DCHECK_NE(&from, this);
  const cacheinfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<cacheinfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:cacheinfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:cacheinfo)
    MergeFrom(*source);
  }
}

void cacheinfo::MergeFrom(const cacheinfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cacheinfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      lavadb_cl5_modid_ = from.lavadb_cl5_modid_;
    }
    if (cached_has_bits & 0x00000002u) {
      lavadb_cl5_cmdid_ = from.lavadb_cl5_cmdid_;
    }
    if (cached_has_bits & 0x00000004u) {
      lavadb_tid_ = from.lavadb_tid_;
    }
    if (cached_has_bits & 0x00000008u) {
      lavadb_cid_ = from.lavadb_cid_;
    }
    if (cached_has_bits & 0x00000010u) {
      idcnum_ = from.idcnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void cacheinfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:cacheinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void cacheinfo::CopyFrom(const cacheinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cacheinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool cacheinfo::IsInitialized() const {
  return true;
}

void cacheinfo::InternalSwap(cacheinfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(cacheinfo, idcnum_)
      + sizeof(cacheinfo::idcnum_)
      - PROTOBUF_FIELD_OFFSET(cacheinfo, lavadb_cl5_modid_)>(
          reinterpret_cast<char*>(&lavadb_cl5_modid_),
          reinterpret_cast<char*>(&other->lavadb_cl5_modid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata cacheinfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class idcitem::_Internal {
 public:
  using HasBits = decltype(std::declval<idcitem>()._has_bits_);
  static void set_has_idc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uploadstate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

idcitem::idcitem(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:idcitem)
}
idcitem::idcitem(const idcitem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&idc_, &from.idc_,
    static_cast<size_t>(reinterpret_cast<char*>(&uploadstate_) -
    reinterpret_cast<char*>(&idc_)) + sizeof(uploadstate_));
  // @@protoc_insertion_point(copy_constructor:idcitem)
}

void idcitem::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&idc_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&uploadstate_) -
      reinterpret_cast<char*>(&idc_)) + sizeof(uploadstate_));
}

idcitem::~idcitem() {
  // @@protoc_insertion_point(destructor:idcitem)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void idcitem::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void idcitem::ArenaDtor(void* object) {
  idcitem* _this = reinterpret_cast< idcitem* >(object);
  (void)_this;
}
void idcitem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void idcitem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const idcitem& idcitem::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_idcitem_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void idcitem::Clear() {
// @@protoc_insertion_point(message_clear_start:idcitem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&idc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&uploadstate_) -
        reinterpret_cast<char*>(&idc_)) + sizeof(uploadstate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* idcitem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 idc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_idc(&has_bits);
          idc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ctime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 uploadstate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_uploadstate(&has_bits);
          uploadstate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* idcitem::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:idcitem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 idc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_idc(), target);
  }

  // required uint32 ctime = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ctime(), target);
  }

  // required uint32 uploadstate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_uploadstate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:idcitem)
  return target;
}

size_t idcitem::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:idcitem)
  size_t total_size = 0;

  if (_internal_has_idc()) {
    // required uint32 idc = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_idc());
  }

  if (_internal_has_ctime()) {
    // required uint32 ctime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());
  }

  if (_internal_has_uploadstate()) {
    // required uint32 uploadstate = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_uploadstate());
  }

  return total_size;
}
size_t idcitem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:idcitem)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 idc = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_idc());

    // required uint32 ctime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ctime());

    // required uint32 uploadstate = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_uploadstate());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void idcitem::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:idcitem)
  GOOGLE_DCHECK_NE(&from, this);
  const idcitem* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<idcitem>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:idcitem)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:idcitem)
    MergeFrom(*source);
  }
}

void idcitem::MergeFrom(const idcitem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:idcitem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      idc_ = from.idc_;
    }
    if (cached_has_bits & 0x00000002u) {
      ctime_ = from.ctime_;
    }
    if (cached_has_bits & 0x00000004u) {
      uploadstate_ = from.uploadstate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void idcitem::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:idcitem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void idcitem::CopyFrom(const idcitem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:idcitem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool idcitem::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void idcitem::InternalSwap(idcitem* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(idcitem, uploadstate_)
      + sizeof(idcitem::uploadstate_)
      - PROTOBUF_FIELD_OFFSET(idcitem, idc_)>(
          reinterpret_cast<char*>(&idc_),
          reinterpret_cast<char*>(&other->idc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata idcitem::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class sha1storeinfo::_Internal {
 public:
  using HasBits = decltype(std::declval<sha1storeinfo>()._has_bits_);
  static void set_has_sha(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::storeinfo& info(const sha1storeinfo* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::cacheinfo& cache_info(const sha1storeinfo* msg);
  static void set_has_cache_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::storeinfo&
sha1storeinfo::_Internal::info(const sha1storeinfo* msg) {
  return *msg->info_;
}
const ::cacheinfo&
sha1storeinfo::_Internal::cache_info(const sha1storeinfo* msg) {
  return *msg->cache_info_;
}
sha1storeinfo::sha1storeinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sha1storeinfo)
}
sha1storeinfo::sha1storeinfo(const sha1storeinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_sha()) {
    sha_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sha(), 
      GetArena());
  }
  if (from._internal_has_info()) {
    info_ = new ::storeinfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  if (from._internal_has_cache_info()) {
    cache_info_ = new ::cacheinfo(*from.cache_info_);
  } else {
    cache_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sha1storeinfo)
}

void sha1storeinfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_sha1storeinfo_cos_5fcomm_2eproto.base);
  sha_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&info_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&cache_info_) -
      reinterpret_cast<char*>(&info_)) + sizeof(cache_info_));
}

sha1storeinfo::~sha1storeinfo() {
  // @@protoc_insertion_point(destructor:sha1storeinfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void sha1storeinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  sha_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete info_;
  if (this != internal_default_instance()) delete cache_info_;
}

void sha1storeinfo::ArenaDtor(void* object) {
  sha1storeinfo* _this = reinterpret_cast< sha1storeinfo* >(object);
  (void)_this;
}
void sha1storeinfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void sha1storeinfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const sha1storeinfo& sha1storeinfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_sha1storeinfo_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void sha1storeinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sha1storeinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sha_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(info_ != nullptr);
      info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cache_info_ != nullptr);
      cache_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* sha1storeinfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes sha = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_sha();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .storeinfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .cacheinfo cache_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cache_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* sha1storeinfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sha1storeinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes sha = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_sha(), target);
  }

  // optional .storeinfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::info(this), target, stream);
  }

  // optional .cacheinfo cache_info = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cache_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sha1storeinfo)
  return target;
}

size_t sha1storeinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sha1storeinfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes sha = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sha());
    }

    // optional .storeinfo info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

    // optional .cacheinfo cache_info = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cache_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void sha1storeinfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sha1storeinfo)
  GOOGLE_DCHECK_NE(&from, this);
  const sha1storeinfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<sha1storeinfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sha1storeinfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sha1storeinfo)
    MergeFrom(*source);
  }
}

void sha1storeinfo::MergeFrom(const sha1storeinfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sha1storeinfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sha(from._internal_sha());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_info()->::storeinfo::MergeFrom(from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_cache_info()->::cacheinfo::MergeFrom(from._internal_cache_info());
    }
  }
}

void sha1storeinfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sha1storeinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void sha1storeinfo::CopyFrom(const sha1storeinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sha1storeinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool sha1storeinfo::IsInitialized() const {
  return true;
}

void sha1storeinfo::InternalSwap(sha1storeinfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sha_.Swap(&other->sha_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(sha1storeinfo, cache_info_)
      + sizeof(sha1storeinfo::cache_info_)
      - PROTOBUF_FIELD_OFFSET(sha1storeinfo, info_)>(
          reinterpret_cast<char*>(&info_),
          reinterpret_cast<char*>(&other->info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata sha1storeinfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosUploadCacheData::_Internal {
 public:
  using HasBits = decltype(std::declval<CosUploadCacheData>()._has_bits_);
  static void set_has_datasize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CosUploadCacheData::CosUploadCacheData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosUploadCacheData)
}
CosUploadCacheData::CosUploadCacheData(const CosUploadCacheData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArena());
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(ctime_));
  // @@protoc_insertion_point(copy_constructor:CosUploadCacheData)
}

void CosUploadCacheData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CosUploadCacheData_cos_5fcomm_2eproto.base);
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
      reinterpret_cast<char*>(&offset_)) + sizeof(ctime_));
}

CosUploadCacheData::~CosUploadCacheData() {
  // @@protoc_insertion_point(destructor:CosUploadCacheData)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosUploadCacheData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CosUploadCacheData::ArenaDtor(void* object) {
  CosUploadCacheData* _this = reinterpret_cast< CosUploadCacheData* >(object);
  (void)_this;
}
void CosUploadCacheData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosUploadCacheData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosUploadCacheData& CosUploadCacheData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosUploadCacheData_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosUploadCacheData::Clear() {
// @@protoc_insertion_point(message_clear_start:CosUploadCacheData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    value_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ctime_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(ctime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosUploadCacheData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 datasize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_datasize(&has_bits);
          datasize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ctime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosUploadCacheData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosUploadCacheData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 datasize = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_datasize(), target);
  }

  // optional uint64 offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_offset(), target);
  }

  // optional uint32 ctime = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ctime(), target);
  }

  // optional bytes value = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosUploadCacheData)
  return target;
}

size_t CosUploadCacheData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosUploadCacheData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes value = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional uint64 offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_offset());
    }

    // optional uint32 datasize = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datasize());
    }

    // optional uint32 ctime = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ctime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosUploadCacheData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosUploadCacheData)
  GOOGLE_DCHECK_NE(&from, this);
  const CosUploadCacheData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosUploadCacheData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosUploadCacheData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosUploadCacheData)
    MergeFrom(*source);
  }
}

void CosUploadCacheData::MergeFrom(const CosUploadCacheData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosUploadCacheData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      datasize_ = from.datasize_;
    }
    if (cached_has_bits & 0x00000008u) {
      ctime_ = from.ctime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosUploadCacheData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosUploadCacheData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosUploadCacheData::CopyFrom(const CosUploadCacheData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosUploadCacheData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosUploadCacheData::IsInitialized() const {
  return true;
}

void CosUploadCacheData::InternalSwap(CosUploadCacheData* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  value_.Swap(&other->value_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CosUploadCacheData, ctime_)
      + sizeof(CosUploadCacheData::ctime_)
      - PROTOBUF_FIELD_OFFSET(CosUploadCacheData, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CosUploadCacheData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosTfsIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<CosTfsIndex>()._has_bits_);
  static void set_has_chid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_datasize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CosTfsIndex::CosTfsIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosTfsIndex)
}
CosTfsIndex::CosTfsIndex(const CosTfsIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&chid_, &from.chid_,
    static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
    reinterpret_cast<char*>(&chid_)) + sizeof(ctime_));
  // @@protoc_insertion_point(copy_constructor:CosTfsIndex)
}

void CosTfsIndex::SharedCtor() {
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&chid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
      reinterpret_cast<char*>(&chid_)) + sizeof(ctime_));
}

CosTfsIndex::~CosTfsIndex() {
  // @@protoc_insertion_point(destructor:CosTfsIndex)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosTfsIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CosTfsIndex::ArenaDtor(void* object) {
  CosTfsIndex* _this = reinterpret_cast< CosTfsIndex* >(object);
  (void)_this;
}
void CosTfsIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosTfsIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosTfsIndex& CosTfsIndex::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosTfsIndex_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosTfsIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:CosTfsIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&chid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ctime_) -
        reinterpret_cast<char*>(&chid_)) + sizeof(ctime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosTfsIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 chid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_chid(&has_bits);
          chid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 fid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_fid(&has_bits);
          fid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datasize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_datasize(&has_bits);
          datasize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ctime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosTfsIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosTfsIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 chid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_chid(), target);
  }

  // optional uint32 fid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fid(), target);
  }

  // optional uint32 datasize = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_datasize(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional uint32 ctime = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ctime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosTfsIndex)
  return target;
}

size_t CosTfsIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosTfsIndex)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 chid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_chid());
    }

    // optional uint32 fid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_fid());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_offset());
    }

    // optional uint32 datasize = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datasize());
    }

    // optional uint32 ctime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ctime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosTfsIndex::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosTfsIndex)
  GOOGLE_DCHECK_NE(&from, this);
  const CosTfsIndex* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosTfsIndex>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosTfsIndex)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosTfsIndex)
    MergeFrom(*source);
  }
}

void CosTfsIndex::MergeFrom(const CosTfsIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosTfsIndex)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      chid_ = from.chid_;
    }
    if (cached_has_bits & 0x00000002u) {
      fid_ = from.fid_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      datasize_ = from.datasize_;
    }
    if (cached_has_bits & 0x00000010u) {
      ctime_ = from.ctime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosTfsIndex::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosTfsIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosTfsIndex::CopyFrom(const CosTfsIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosTfsIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosTfsIndex::IsInitialized() const {
  return true;
}

void CosTfsIndex::InternalSwap(CosTfsIndex* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CosTfsIndex, ctime_)
      + sizeof(CosTfsIndex::ctime_)
      - PROTOBUF_FIELD_OFFSET(CosTfsIndex, chid_)>(
          reinterpret_cast<char*>(&chid_),
          reinterpret_cast<char*>(&other->chid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CosTfsIndex::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CheckTfsinfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckTfsinfo>()._has_bits_);
  static void set_has_tfs_cl5_modid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tfs_cl5_cmid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_idcnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_isprefix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CheckTfsinfo::CheckTfsinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  datalist_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CheckTfsinfo)
}
CheckTfsinfo::CheckTfsinfo(const CheckTfsinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      datalist_(from.datalist_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&tfs_cl5_modid_, &from.tfs_cl5_modid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isprefix_) -
    reinterpret_cast<char*>(&tfs_cl5_modid_)) + sizeof(isprefix_));
  // @@protoc_insertion_point(copy_constructor:CheckTfsinfo)
}

void CheckTfsinfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CheckTfsinfo_cos_5fcomm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&tfs_cl5_modid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&isprefix_) -
      reinterpret_cast<char*>(&tfs_cl5_modid_)) + sizeof(isprefix_));
}

CheckTfsinfo::~CheckTfsinfo() {
  // @@protoc_insertion_point(destructor:CheckTfsinfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CheckTfsinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CheckTfsinfo::ArenaDtor(void* object) {
  CheckTfsinfo* _this = reinterpret_cast< CheckTfsinfo* >(object);
  (void)_this;
}
void CheckTfsinfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CheckTfsinfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckTfsinfo& CheckTfsinfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CheckTfsinfo_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CheckTfsinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CheckTfsinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  datalist_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&tfs_cl5_modid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isprefix_) -
        reinterpret_cast<char*>(&tfs_cl5_modid_)) + sizeof(isprefix_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckTfsinfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 tfs_cl5_modid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tfs_cl5_modid(&has_bits);
          tfs_cl5_modid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tfs_cl5_cmid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_tfs_cl5_cmid(&has_bits);
          tfs_cl5_cmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 idcnum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_idcnum(&has_bits);
          idcnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool isprefix = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_isprefix(&has_bits);
          isprefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .CosTfsIndex datalist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_datalist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckTfsinfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckTfsinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 tfs_cl5_modid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tfs_cl5_modid(), target);
  }

  // optional uint32 tfs_cl5_cmid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tfs_cl5_cmid(), target);
  }

  // optional uint32 idcnum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_idcnum(), target);
  }

  // optional bool isprefix = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_isprefix(), target);
  }

  // repeated .CosTfsIndex datalist = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_datalist_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_datalist(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckTfsinfo)
  return target;
}

size_t CheckTfsinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CheckTfsinfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CosTfsIndex datalist = 5;
  total_size += 1UL * this->_internal_datalist_size();
  for (const auto& msg : this->datalist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 tfs_cl5_modid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_tfs_cl5_modid());
    }

    // optional uint32 tfs_cl5_cmid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_tfs_cl5_cmid());
    }

    // optional uint32 idcnum = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_idcnum());
    }

    // optional bool isprefix = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckTfsinfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CheckTfsinfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckTfsinfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckTfsinfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CheckTfsinfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CheckTfsinfo)
    MergeFrom(*source);
  }
}

void CheckTfsinfo::MergeFrom(const CheckTfsinfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CheckTfsinfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  datalist_.MergeFrom(from.datalist_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      tfs_cl5_modid_ = from.tfs_cl5_modid_;
    }
    if (cached_has_bits & 0x00000002u) {
      tfs_cl5_cmid_ = from.tfs_cl5_cmid_;
    }
    if (cached_has_bits & 0x00000004u) {
      idcnum_ = from.idcnum_;
    }
    if (cached_has_bits & 0x00000008u) {
      isprefix_ = from.isprefix_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CheckTfsinfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CheckTfsinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckTfsinfo::CopyFrom(const CheckTfsinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CheckTfsinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckTfsinfo::IsInitialized() const {
  return true;
}

void CheckTfsinfo::InternalSwap(CheckTfsinfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  datalist_.InternalSwap(&other->datalist_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckTfsinfo, isprefix_)
      + sizeof(CheckTfsinfo::isprefix_)
      - PROTOBUF_FIELD_OFFSET(CheckTfsinfo, tfs_cl5_modid_)>(
          reinterpret_cast<char*>(&tfs_cl5_modid_),
          reinterpret_cast<char*>(&other->tfs_cl5_modid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckTfsinfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CosLavaDBIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<CosLavaDBIndex>()._has_bits_);
  static void set_has_keyhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_keyrange(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_datasize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ctime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CosLavaDBIndex::CosLavaDBIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CosLavaDBIndex)
}
CosLavaDBIndex::CosLavaDBIndex(const CosLavaDBIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  keyhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_keyhash()) {
    keyhash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyhash(), 
      GetArena());
  }
  keyrange_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_keyrange()) {
    keyrange_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyrange(), 
      GetArena());
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(ctime_));
  // @@protoc_insertion_point(copy_constructor:CosLavaDBIndex)
}

void CosLavaDBIndex::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CosLavaDBIndex_cos_5fcomm_2eproto.base);
  keyhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyrange_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
      reinterpret_cast<char*>(&offset_)) + sizeof(ctime_));
}

CosLavaDBIndex::~CosLavaDBIndex() {
  // @@protoc_insertion_point(destructor:CosLavaDBIndex)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CosLavaDBIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  keyhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyrange_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CosLavaDBIndex::ArenaDtor(void* object) {
  CosLavaDBIndex* _this = reinterpret_cast< CosLavaDBIndex* >(object);
  (void)_this;
}
void CosLavaDBIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CosLavaDBIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CosLavaDBIndex& CosLavaDBIndex::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CosLavaDBIndex_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CosLavaDBIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:CosLavaDBIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      keyhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      keyrange_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ctime_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(ctime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CosLavaDBIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes keyhash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_keyhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes keyrange = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_keyrange();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datasize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_datasize(&has_bits);
          datasize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ctime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CosLavaDBIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CosLavaDBIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes keyhash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_keyhash(), target);
  }

  // optional bytes keyrange = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_keyrange(), target);
  }

  // optional uint32 datasize = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_datasize(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional uint32 ctime = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ctime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CosLavaDBIndex)
  return target;
}

size_t CosLavaDBIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CosLavaDBIndex)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes keyhash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_keyhash());
    }

    // optional bytes keyrange = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_keyrange());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_offset());
    }

    // optional uint32 datasize = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_datasize());
    }

    // optional uint32 ctime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ctime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CosLavaDBIndex::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CosLavaDBIndex)
  GOOGLE_DCHECK_NE(&from, this);
  const CosLavaDBIndex* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CosLavaDBIndex>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CosLavaDBIndex)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CosLavaDBIndex)
    MergeFrom(*source);
  }
}

void CosLavaDBIndex::MergeFrom(const CosLavaDBIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CosLavaDBIndex)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_keyhash(from._internal_keyhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_keyrange(from._internal_keyrange());
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      datasize_ = from.datasize_;
    }
    if (cached_has_bits & 0x00000010u) {
      ctime_ = from.ctime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CosLavaDBIndex::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CosLavaDBIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CosLavaDBIndex::CopyFrom(const CosLavaDBIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CosLavaDBIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CosLavaDBIndex::IsInitialized() const {
  return true;
}

void CosLavaDBIndex::InternalSwap(CosLavaDBIndex* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  keyhash_.Swap(&other->keyhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  keyrange_.Swap(&other->keyrange_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CosLavaDBIndex, ctime_)
      + sizeof(CosLavaDBIndex::ctime_)
      - PROTOBUF_FIELD_OFFSET(CosLavaDBIndex, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CosLavaDBIndex::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CheckLavaDBinfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckLavaDBinfo>()._has_bits_);
  static void set_has_lavadb_cl5_modid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lavadb_cl5_cmid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lavadb_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lavadb_cid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CheckLavaDBinfo::CheckLavaDBinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  datalist_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CheckLavaDBinfo)
}
CheckLavaDBinfo::CheckLavaDBinfo(const CheckLavaDBinfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      datalist_(from.datalist_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&lavadb_cl5_modid_, &from.lavadb_cl5_modid_,
    static_cast<size_t>(reinterpret_cast<char*>(&lavadb_cid_) -
    reinterpret_cast<char*>(&lavadb_cl5_modid_)) + sizeof(lavadb_cid_));
  // @@protoc_insertion_point(copy_constructor:CheckLavaDBinfo)
}

void CheckLavaDBinfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CheckLavaDBinfo_cos_5fcomm_2eproto.base);
  ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
      reinterpret_cast<char*>(&lavadb_cl5_modid_) - reinterpret_cast<char*>(this)),
      0, static_cast<size_t>(reinterpret_cast<char*>(&lavadb_cid_) -
      reinterpret_cast<char*>(&lavadb_cl5_modid_)) + sizeof(lavadb_cid_));
}

CheckLavaDBinfo::~CheckLavaDBinfo() {
  // @@protoc_insertion_point(destructor:CheckLavaDBinfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CheckLavaDBinfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CheckLavaDBinfo::ArenaDtor(void* object) {
  CheckLavaDBinfo* _this = reinterpret_cast< CheckLavaDBinfo* >(object);
  (void)_this;
}
void CheckLavaDBinfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CheckLavaDBinfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckLavaDBinfo& CheckLavaDBinfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CheckLavaDBinfo_cos_5fcomm_2eproto.base);
  return *internal_default_instance();
}


void CheckLavaDBinfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CheckLavaDBinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  datalist_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&lavadb_cl5_modid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lavadb_cid_) -
        reinterpret_cast<char*>(&lavadb_cl5_modid_)) + sizeof(lavadb_cid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckLavaDBinfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 lavadb_cl5_modid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_lavadb_cl5_modid(&has_bits);
          lavadb_cl5_modid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cl5_cmid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lavadb_cl5_cmid(&has_bits);
          lavadb_cl5_cmid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_tid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_lavadb_tid(&has_bits);
          lavadb_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lavadb_cid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lavadb_cid(&has_bits);
          lavadb_cid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .CosLavaDBIndex datalist = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_datalist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckLavaDBinfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckLavaDBinfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 lavadb_cl5_modid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_lavadb_cl5_modid(), target);
  }

  // optional uint32 lavadb_cl5_cmid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lavadb_cl5_cmid(), target);
  }

  // optional uint32 lavadb_tid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_lavadb_tid(), target);
  }

  // optional uint32 lavadb_cid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_lavadb_cid(), target);
  }

  // repeated .CosLavaDBIndex datalist = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_datalist_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_datalist(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckLavaDBinfo)
  return target;
}

size_t CheckLavaDBinfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CheckLavaDBinfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CosLavaDBIndex datalist = 5;
  total_size += 1UL * this->_internal_datalist_size();
  for (const auto& msg : this->datalist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 lavadb_cl5_modid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cl5_modid());
    }

    // optional uint32 lavadb_cl5_cmid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cl5_cmid());
    }

    // optional uint32 lavadb_tid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_tid());
    }

    // optional uint32 lavadb_cid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lavadb_cid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckLavaDBinfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CheckLavaDBinfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckLavaDBinfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckLavaDBinfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CheckLavaDBinfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CheckLavaDBinfo)
    MergeFrom(*source);
  }
}

void CheckLavaDBinfo::MergeFrom(const CheckLavaDBinfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CheckLavaDBinfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  datalist_.MergeFrom(from.datalist_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      lavadb_cl5_modid_ = from.lavadb_cl5_modid_;
    }
    if (cached_has_bits & 0x00000002u) {
      lavadb_cl5_cmid_ = from.lavadb_cl5_cmid_;
    }
    if (cached_has_bits & 0x00000004u) {
      lavadb_tid_ = from.lavadb_tid_;
    }
    if (cached_has_bits & 0x00000008u) {
      lavadb_cid_ = from.lavadb_cid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CheckLavaDBinfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CheckLavaDBinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckLavaDBinfo::CopyFrom(const CheckLavaDBinfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CheckLavaDBinfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckLavaDBinfo::IsInitialized() const {
  return true;
}

void CheckLavaDBinfo::InternalSwap(CheckLavaDBinfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  datalist_.InternalSwap(&other->datalist_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckLavaDBinfo, lavadb_cid_)
      + sizeof(CheckLavaDBinfo::lavadb_cid_)
      - PROTOBUF_FIELD_OFFSET(CheckLavaDBinfo, lavadb_cl5_modid_)>(
          reinterpret_cast<char*>(&lavadb_cl5_modid_),
          reinterpret_cast<char*>(&other->lavadb_cl5_modid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckLavaDBinfo::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ShaMainRecord* Arena::CreateMaybeMessage< ::ShaMainRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShaMainRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::CasKeyRecord* Arena::CreateMaybeMessage< ::CasKeyRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CasKeyRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::PartRecord* Arena::CreateMaybeMessage< ::PartRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PartRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::CosDataIndex* Arena::CreateMaybeMessage< ::CosDataIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosDataIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::CosDataIndexRsp* Arena::CreateMaybeMessage< ::CosDataIndexRsp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosDataIndexRsp >(arena);
}
template<> PROTOBUF_NOINLINE ::CosPartItem* Arena::CreateMaybeMessage< ::CosPartItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosPartItem >(arena);
}
template<> PROTOBUF_NOINLINE ::CosPartdeleteItem* Arena::CreateMaybeMessage< ::CosPartdeleteItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosPartdeleteItem >(arena);
}
template<> PROTOBUF_NOINLINE ::delstorinfo* Arena::CreateMaybeMessage< ::delstorinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::delstorinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::storeinfo* Arena::CreateMaybeMessage< ::storeinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storeinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::cacheinfo* Arena::CreateMaybeMessage< ::cacheinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::cacheinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::idcitem* Arena::CreateMaybeMessage< ::idcitem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::idcitem >(arena);
}
template<> PROTOBUF_NOINLINE ::sha1storeinfo* Arena::CreateMaybeMessage< ::sha1storeinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sha1storeinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CosUploadCacheData* Arena::CreateMaybeMessage< ::CosUploadCacheData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosUploadCacheData >(arena);
}
template<> PROTOBUF_NOINLINE ::CosTfsIndex* Arena::CreateMaybeMessage< ::CosTfsIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosTfsIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::CheckTfsinfo* Arena::CreateMaybeMessage< ::CheckTfsinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CheckTfsinfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CosLavaDBIndex* Arena::CreateMaybeMessage< ::CosLavaDBIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CosLavaDBIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::CheckLavaDBinfo* Arena::CreateMaybeMessage< ::CheckLavaDBinfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CheckLavaDBinfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
